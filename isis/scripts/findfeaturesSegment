#!/usr/bin/env python

import os
import sys
import re 

import kalasiris as kisis

import subprocess
import pvl

from glob import glob
import logging
from pathlib import Path
import logging as log
import itertools 
from copy import deepcopy
import tempfile

import plio
from plio.io import io_controlnetwork as cnet
from plio.io import isis_serial_number as sn

MAX_LEN = 30000

def parse_parameters():
  # Use a regular expression to extract the parameter name and value from each
  # key-value pair in the parameter string.
  pattern = r'(\w+)=(\S+)'
  
  # Create a dictionary to store the parameter names and values.
  params = {}
  for arg in sys.argv[1:]:
    # Extract the parameter name and value from the argument.
    matches = re.findall(pattern, arg)
    for match in matches:
      name = match[0]
      value = match[1]
    
      # Add the parameter name and value to the dictionary.
      params[name.lower()] = value
  
  return params

def read_cubelist(cube_list : Path):
    """
    read_cubelist accepts a filelist path and returns a list object

    Parameters
    ----------
    cube_list : Path
                path-like object pointing to filelist 

    Returns
    -------
    list
        list of files 
    """
    with open(cube_list) as c:
        content = c.read()
        content = content.strip()
        files = content.split("\n")
        return files 


def segment(img_path : Path, nlines : int = MAX_LEN):
    """
    Segments an image into multiple parts.

    Parameters
    ----------
    img_path : path-like
        The path to the image to be segmented.
    nlines : int
        The number of lines in each segment (defaults to MAX_LEN).

    Returns
    -------
    segment_metadata : list of dict
        A list of dictionaries containing metadata for each segment.
    """

    if isinstance(img_path, str):
        img_path = Path(img_path)
    log.debug(f"nlines: {nlines}")

    segment_metadata = {}
    try:
        ret = kisis.segment(img_path, nl=MAX_LEN, overlap=0)
        segment_metadata = pvl.loads(ret.stdout)
        
        # comes nested in a "results" group, trim it off
        segment_metadata = [s[1] for s in segment_metadata]
        
        glob_str = str(img_path.parent / img_path.stem) + ".segment*"
        log.debug(f"globbing segments: glob({glob_str})")
        segments = sorted(glob(glob_str))
        log.debug(f"segments: {segments}")
        for s, meta in zip(segments, segment_metadata):
            meta["Path"] = s
            meta["SN"] = sn.generate_serial_number(s)
            # recompute footprint
            kisis.footprintinit(s)
        
        seg_dict_keys = [f"seg{n}" for n in range(1,len(segments)+1)]
        segment_dict = dict(zip(seg_dict_keys, segment_metadata))
        log.debug(f"Segment dict: {segment_dict}")
    except subprocess.CalledProcessError as err:
        print('Had an ISIS error:')
        print(' '.join(err.cmd))
        print(err.stdout)
        print(err.stderr)
        raise err
    
    return segment_metadata

if __name__ == "__main__": 
    params = parse_parameters()
    if (params.get("debug") == "True"):
        log.basicConfig(level=logging.DEBUG)
    else: 
        log.basicConfig(level=logging.INFO)    

    if "nl" not in params : 
        raise ValueError('**User Error** invalid command Line. Missing Parameter "nl"')

    img_list = []
    if "from" in params:
        img_list = [params["from"]]
    elif "fromlist" in params:
        img_list = read_cubelist(params["fromlist"])
    else:
        raise ValueError('**User Error** invalid command Line. Missing Parameter "nl"')    

    from_segments = {}

    for img in img_list:
        res = segment(img)
        from_segments[img] = res
        
    match_segments = segment(params["match"])
    max_from_segments = max([len(v) for k,v in from_segments.items()])

    onets = []
    for i in range(len(match_segments)):
        for j in range(max_from_segments): 
            match_segment_n = i+1
            from_segment_n = j+1
            
            new_params = deepcopy(params)

            # make sure none of these keys are still in the params
            new_params.pop("fromlist", None)
            new_params.pop("from", None)

            new_params["match"] = match_segments[i]["Path"]

            og_onet = Path(params["onet"])
            og_tolist = Path(params["tolist"])
            og_pointid = params["pointid"]
            og_networkid = params["networkid"]
            
            from_images = [segment[j]["Path"] for image, segment in from_segments.items() if j < len(segment)]
            starting_lines = [segment[j]["StartingLine"] for image, segment in from_segments.items() if j < len(segment)]
            
            fromlist_path = Path(og_tolist.parent / f"from_images_segment{from_segment_n}.lis")
            log.debug(f"fromlist: {from_images}")
            
            if not fromlist_path.exists():
                log.debug(f"writing to: {fromlist_path}")
                kisis.fromlist.make(from_images, fromlist_path)
            else:
                log.debug(f"{fromlist_path} already exists")
            
            if "debuglog" in new_params:
                og_log =  Path(new_params["debuglog"])
                new_log = og_log.parent / f"{og_log.stem}.match_segment{match_segment_n}.from_segment{from_segment_n}{og_log.suffix}" 
                new_params["debuglog"] = str(new_log)
                
            new_params["fromlist"] = str(fromlist_path)
            new_params["networkid"] = og_networkid + f"_match_segment{match_segment_n}_from_segment{from_segment_n}"
            new_params["pointid"] = og_pointid + f"_match_segment{match_segment_n}_from_segment{from_segment_n}"
            new_params["onet"] = f"{og_onet.parent/og_onet.stem}.match_segment{match_segment_n}.from_segment{from_segment_n}.net"
            new_params["tolist"] = f"{og_tolist.parent/og_tolist.stem}.match_segment{match_segment_n}.from_segment{from_segment_n}.lis"

            log.debug(new_params)
            
            # check for overlaps
            is_overlapping = False
            with tempfile.TemporaryDirectory() as tmpdir:
                tmpdir = Path(tmpdir)
                overlapfromlist = tmpdir / "fromlist.lis"
                overlaptolist = tmpdir / "tolist.lis"
                
                kisis.fromlist.make([*from_images, new_params["match"]], overlapfromlist)
                kisis.findimageoverlaps(fromlist=overlapfromlist, overlaplist=overlaptolist)
                ret = kisis.overlapstats(fromlist=overlapfromlist, overlaplist=overlaptolist)
                stats = pvl.loads(ret.stdout)
                log.debug(f"overlap stats: {ret.stdout}")
                is_overlapping = not all([k[1].get("NoOverlap", "") == new_params["match"] for k in stats])
                
            log.debug(f"Is overlapping? {is_overlapping}")
            
            if is_overlapping: 
                try:
                    ret = kisis.findfeatures(**new_params)
                    log.debug(f"returned: {ret}")
                except subprocess.CalledProcessError as err:
                    log.debug('Had an ISIS error:')
                    log.debug(' '.join(err.cmd))
                    log.debug(err.stdout)
                    log.debug(err.stderr)
            
                segmented_net = cnet.from_isis(new_params["onet"])

                # starting sample in inclusive, so subtract 1
                segmented_net.loc[segmented_net.serialnumber == match_segments[i]["SN"], "line"] += match_segments[i]["StartingLine"]-1 

                # offset the images 
                for k, image in enumerate(from_images):
                    image_sn = sn.generate_serial_number(image)

                    # starting sample is inclusive, so subtract 1
                    segmented_net.loc[segmented_net.serialnumber == image_sn, "line"] += starting_lines[k]-1
                cnet.to_isis(segmented_net, new_params["onet"], targetname="moon")
                onets.append(new_params["onet"])
    
    # merge the networks 
    kisis.fromlist.make(onets, "nets.lis")

    try:
        kisis.cnetmerge(clist = "nets.lis", onet="/Users/krodriguez/lronac_ff2/test.net", networkid=params["networkid"], description=params["description"])
    except subprocess.CalledProcessError as err:
        log.debug('Had an ISIS error:')
        log.debug(' '.join(err.cmd))
        log.debug(err.stdout)
        log.debug(err.stderr)