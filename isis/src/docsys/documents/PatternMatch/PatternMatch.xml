<?xml version="1.0" encoding="UTF-8" ?>

<documentation xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://isis.astrogeology.usgs.gov/Schemas/Documentation/documentation.xsd">

  <files>
    <file>
      <body>

        <h3>Table of Contents</h3>
        <ol type="I">
          <li><a href="#Introduction">Introduction</a></li>
          <ol type="i">
            <li><a href="#PluginsAndPvl">Plugins and PVL</a></li>
          </ol>

          <li><a href="#Chips">Chips</a></li>
          <ol type="i">
            <li><a href="#PatternChip">Pattern Chip</a></li>
            <li><a href="#SearchChip">Search Chip</a></li>
            <li><a href="#Restrictions">Restrictions</a></li>
          </ol>

          <li><a href="#MatchAlgorithms">Match Algorithms</a></li>
          <ol type="i">
            <li><a href="#MaximumCorrelation">Maximum Correlation</a></li>
            <li><a href="#MinimumDifference">Minimum Difference</a></li>
            <li><a href="#Gruen">Gruen</a></li>
            <li><a href="#Tolerance">Algorithm Tolerance Parameter</a></li>
          </ol>

          <li><a href="#CreatingFitChip">Creating a Fit Chip</a></li>
          <ol type="i">
            <li><a href="#DenseWalk">Dense Walk</a></li>
          </ol>

          <li><a href="#SubPixelAccuracy">Sub-Pixel Accuracy</a></li>
          <ol type="i">
            <li><a href="#SurfaceModeling (Subpixel Algorithm)">Surface Modeling</a></li>
            <li><a href="#DistanceTolerance">Distance Tolerance</a></li>
            <li><a href="#WindowSize">Window Size</a></li>
          </ol>

          <li><a href="#AdvancedFeatures">Advanced Features</a></li>
          <ol type="i">
            <li>
              <a href="#RestrictingPixelRanges">Restricting Pixel Ranges</a>
            </li>
            <li>
              <a href="#ValidPixelCount">Valid Pixel Count</a>
            </li>
            <li>
              <a href="#ReductionFactor">Reduction Factor</a>
            </li>
            <li>
              <a href="#GeoWarping">Geometric Warping of Pattern Cubes</a>
            </li>
            <li><a href="#ZScoreTest">Z-Score Test</a></li>
            <li><a href="#GradientFilters">Gradient Filters</a></li>
          </ol>

          <li><a href="#Appendices">Appendices</a></li>
          <ol type="i">
            <li>
              <a href="#DeffileKeywords">Definition File Keywords</a>
            </li>
          </ol>
        </ol>

        <hr />

        <!-- Introduction -->
        <h2><a name="Introduction">Introduction</a></h2>
        <p>
          This document attempts to describe how automatic registration is
          accomplished in ISIS.  In simple terms, automatic registration is
          the attempt to match a pattern in a cube.  For example, given a reseau
          template pattern, we would like to find positions in a cube which
          match the reseau.  Similarly, if we extract from a cube a ground
          feature (e.g. crater, fault line, etc) as a pattern, we would like to
          find the same feature in another overlapping cube to define match
          points.
        </p>

        <h3><a name="PluginsAndPvl">Plugins and PVL</a></h3>
        <p>
          Automatic registration is a tricky subject.  Algorithms and
          parameters that successfully work for one pattern are likely not to
          work for other conditions.  In ISIS, we do not want to restrict our
          registration programs (e.g., coreg, pointreg) to a single algorithm.
          We would view this similar to map projections or camera models.  That
          is, if a particular registration algorithm meets our needs we can
          choose to use it, however, if none meet our needs a new algorithm can
          be developed.  A key element is we want the new algorithm immediately
          available in all applications without the need to modify them.  We
          will facilitate this requirement through plugins and the use of
          Parameter Value Language (PVL) definition files.   The PVL syntax
          will be introduced gradually as the overall discussion of automatic
          registration progresses.
        </p>

        <!-- Chips -->
        <h2><a name="Chips">Chips</a></h2>
        <p>
          In the simplest terms, automatic registration attempts to find some
          sub-area of a cube (or "pattern" window) inside some subarea of another
          cube (or "search" window).  In ISIS, these "generally" small sub-areas
          of a cube are called "chips".  There are two chips used in automatic
          registration, the "pattern" chip and the "search" chip, corresponding
          to the two sub-areas discussed above.   We will discuss each in more
          detail within the following sections, but for now we describe the
          basic elements of a chip.  That is, an NxM chip is defined to be an N
          samples by M lines region of a cube.  Some key elements of a chip are
          as follows:

          <ol>
            <li>N and M are natural numbers (1, 2, 3, ...)</li>
            <li>Like cubes, chip coordinates are sample/line based and indexed from 1</li>
            <li>The center of the chip is (N-1)/2 + 1 and (M-1)/2 + 1.</li>
          </ol>
        </p>

        <h3><a name="PatternChip">Pattern Chip</a></h3>
        <p>
          The pattern chip contains the data you want to match.  In the past we
          have called this the "truth" chip or "hold" chip.  Both of these
          terms can be confusing.  The term "truth" has different meanings in
          regards to match points and term "hold" is misleading as a pattern
          chip actually floats through the search chip. So we refrain from
          their use and stick with the term "pattern" chip.   The PVL for a
          pattern chip is:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="SearchChip">Search Chip</a></h3>
        <p>
          The search chip is the area of an overlapping cube you believe the
          pattern will fall within.  That is, we will walk the pattern chip
          through the search chip looking for the best match.  The size of the
          search chip defines how far the pattern chip is allowed to deviate
          from a desired center search spot.  Consequently, the search chip
          must be larger than the pattern chip in order for the pattern chip to
          move through the search chip:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Restrictions">Restrictions</a></h3>
        <p>
          From the above discussion of pattern and search chips, an intuition
          should be developing about how changes to one chip will necessitate
          changes to the other.  Because the pattern chip and search chip are
          tightly coupled in this way, there are some restrictions on the
          relative dimensions of the two chips that must be put in place.
          Specifically:

          <ol>
            <li>
              <strong>N + M >= 3</strong>
              <br />
              where N and M are the dimensions of the pattern chip.  This
              ensures the pattern is not a single pixel.  However, in practice,
              small pattern chips often match too many areas in a search chip.
            </li>
            <li>
              <strong>
                N<sub>search</sub> >= N<sub>pattern</sub>+2
              </strong>
              and
              <strong>
                M<sub>search</sub> >= M<sub>pattern</sub>+2
              </strong>
              <br />
              where N and M are again the dimensions of their respective chips.
              This ensures that the pattern chip spans at least a 3x3 window in
              the search chip.  This is a subtle but important requirement for
              surface fitting in order to compute sub-pixel accuracy (which
              will be discussed later in this document).
            </li>
          </ol>
        </p>

        <!-- Match Algorithms -->
        <h2><a name="MatchAlgorithms">Match Algorithms</a></h2>
        <p>
          Rarely in practice will the pixels in a search chip have a one-to-one
          correspondance with some sub-area of the search chip.  Consequently,
          we introduce match algorithms designed to correlate two chips and
          find the "best" match within the search area.
        </p>
        <p>
          An objective of the ISIS automatic registration design is to allow
          for a variety of match algorithms.  For example, an algorithm could
          be developed that works best for matching MGS/MOC wide angle and
          Odyssey Themis IR cameras.  For this objective to be met we will
          utilize applications which allow automatic registration plugins.
          This concept is identical to that of applications which utilize
          camera and/or map projection plugins such as cam2map, map2map, etc.
        </p>
        <p>
          The plugin match algorithm will receive the pattern chip and a
          sub-region of the search chip.  This sub-region will have the same
          dimensions as the pattern chip to allow for a pixel-by-pixel
          comparison of the chips.  The algorithm is expected to return a
          single value that represents the "goodness of fit" (GOF) between the
          two chips.   The definition of the GOF is algorithm dependent.  For
          clarity, we present two types of match algorithms in this document
          with the understanding that more algorithms may be developed in the
          future.
        </p>

        <h3><a name="MaximumCorrelation">Maximum Correlation</a></h3>
        <p>
          This match algorithm computes the correlation coefficient, R, between
          the pattern chip and the sub-region of the search chip as follows:

          <pre style="padding-left:4em;">
            R = Covariance(pattern, subregon) / [Variance(pattern) * Variance(subregion)]

            where -1.0 &lt;= R &lt;= 1.0

            GOF = |R|
          </pre>

          In this algorithm, the "one pixel accuracy" goodness of fit will range from no correlation
          (zero) to perfect correlation (one).  Example PVL for this algorithm
          would as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm
                Name    = MaximumCorrelation
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="MinimumDifference">Minimum Difference</a></h3>
        <p>
          This match algorithm defines goodness-of-fit (one pixel accuracy) as the average absolute
          difference per pixel between the pattern chip and the search
          sub-region.  Specifically, it sums the pixel differences within the
          pattern chip and search sub-region and divides by the total pixel
          count to get an average.  In equation form:

          <pre style="padding-left:4em;">
            GOF =  <span style="font-size:2.0em;">&#931;</span>|pattern(i,j) - subregion(i,j)| / count
          </pre>

          A GOF value of zero indicates a perfect match, while larger values
          indicate a less likely match.  Obviously, negative values could never
          occur.
        </p>
        <p>
          To have your automatic registration use this Minimum Difference
          algorithm, specify the following in the "Algorithm" group of your PVL
          definition file:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm
                Name    = MinimumDifference
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Gruen">Gruen</a></h3>
        <p>
          A modification to the Adaptive Least Squares Correlation algorithm
          was introduced by A.W. Gruen as a flexible technique for image data
          matching.  It allows for simultaneous radiometric corrections and local
          geometrical image shaping in which the system parameters are
          automatically assessed, corrected, and thus optimized during the least
          squares iterations.  The tools of least squares estimation are utilized
          for the assessment of the correlation quality.  The algorithm allows for
          stabilization and improvement of the correlation procedure through the
          simultaneous consideration of geometrical constraints.

          Within ISIS, this algorithm provides adaptive image (chip) registration
          using an Affine transform to iteratively adjust the search chip at each
          iteration.  Each iteration solves for new adjustments to the Affine
          transform until the 6 affine parameters fall below the tolerances as
          specified by the following parameters:
        </p>
        <p>
          <br><h1 align="center">Gruen AutoReg Parameters</h1></br>
          <TABLE BORDER="1">
            <CAPTION>
            </CAPTION>
            <TR>
              <TH>Parameter</TH>
              <TH>Description</TH>
            </TR>
            <TR>
              <TD>Name</TD>
              <TD>
                Name of the algorithm that the set of parameters description apply
                to.  This should be <em>AdaptiveGruen</em>.
              </TD>
            </TR>
            <TR>
              <TD>Tolerance</TD>
              <TD>
                This constrains the eigenvalues of the registration result.
                Registrations with <b>GoodnessOfFit</b> larger than this value are
                rejected.  It is highly recommended this value be utilized as it
                will result in better fits.  A low GOF value near zero represents
                a good fit. (Default: Unbounded)
              </TD>
            </TR>
            <TR>
              <TD>MaximumIterations</TD>
              <TD>
                Maximum number of iterations allowed for the registration processing
                to converge.  (Default: 30)
              </TD>
            </TR>
            <TR>
              <TD>AffineTolerance</TD>
              <TD>
                The amount of offset in pixels an Affine derived points is allowed to
                deviate from the orginal match point. (Default: Unbounded)
              </TD>
            </TR>
            <TR>
              <TD>SpiceTolerance</TD>
              <TD>
                The amount of offset in pixels a registration is allowed to deviate
                from a registered point. (Default: Unbounded)
              </TD>
            </TR>
            <TR>
              <TD>AffineTranslationTolerance</TD>
              <TD>
                Specifies the threshold convergence value of the Affine translation
                shift in line/sample between each Gruen match iteration.  If the
                amout of this value computed in the Gruen algorithm is less than this
                value, it is deemed a match point concerning the translation portion
                of the registered point.  (Default: 0.1)
              </TD>
            </TR>
            <TR>
              <TD>AffineScaleTolerance</TD>
              <TD>
                Specifies the threshold convergence value of the Affine scale in
                line/sample between each Gruen match iteration.  If the amout of this
                value computed in the Gruen algorithm is less than this value, it is
                deemed a match point concerning the scaling portion of the registered
                point. (Default: 0.3)
              </TD>
            </TR>
            <TR>
              <TD>AffineShearTolerance</TD>
              <TD>
                Specifies the threshold convergence value of the Affine shear in
                line/sample between each Gruen match iteration.  If the amout of this
                value computed in the Gruen algorithm is less than this value, it is
                deemed a match point concerning the shearing portion of the registered
                point. (Default: AffineScaleTolerance)
              </TD>
            </TR>
            <TR>
              <TD>RadioShiftTolerance</TD>
              <TD>
                Specifies the threshold convergence value for the radiometric shift of
                the pixel value between each Gruen match iteration.  If the amout of this
                value computed in the Gruen algorithm is less than this value, it is
                deemed a match point concerning the radiometric shift portion of the
                registered point. (Default: Unbounded)
              </TD>
            </TR>
            <TR>
              <TD>RadioGainMinTolerance</TD>
              <TD>
                Specifes the threshold convergence minimum value for the radiometric
                gain of the pixel value between each Gruen match iteration.  If the amout of this
                value computed in the Gruen algorithm is greater than this value and
                less than RadioGainMaxTolerance, it is deemed a match point concerning
                the radiometric gain portion of the registered point. (Default:
                Unbounded)
              </TD>
            </TR>
            <TR>
              <TD>RadioGainMaxTolerance</TD>
              <TD>
                Specifes the threshold convergence maximum value for the radiometric
                gain of the pixel value between each Gruen match iteration.  If the amout of this
                value computed in the Gruen algorithm is less than this value and
                greater than RadioGainMinTolerance, it is deemed a match point
                concerning the radiometric gain portion of the registered point.
                (Default: Unbounded)
              </TD>
            </TR>
            <TR>
              <TD>DefaultRadioShift</TD>
              <TD>
                Sets the default value for the radiometric shift value used as a
                starting point in the Gruen algorithm.  (Default: 0)
              </TD>
            </TR>
            <TR>
              <TD>DefaultRadioGain</TD>
              <TD>
                Sets the default value for the radiometric gain value used as a
                starting point in the Gruen algorithm.  (Default: 0)
              </TD>
            </TR>
          </TABLE>
        </p>

        <h3><a name="Tolerance">Tolerance</a></h3>
        <p>
          In all algorithms we will want to define a tolerance for goodness of
          fit.   The tolerance test must be made by the plugin as the direction
          of the test is dependent on the algorithm.  In our examples, the goodness of
          fit and Tolerance represent a one pixel accuracy level.  The
          MinimumDifference would use a test for "less than" Tolerance,
          MaximumCorrelation would use "greater than" Tolerance, and GruenAdaptive
          would use "less than" Tolerance (the goodness of fit for Gruen is at
          a sub-pixel accuracy). This is represented in PVL in the following fashion:
          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm
                Name      = MaximumCorrelation
                Tolerance = 0.7
              End_Group
            End_Object
          </pre>
        </p>

        <!-- Creating a Fit Chip -->
        <h2><a name="CreatingFitChip">Creating a Fit Chip</a></h2>
        <p>
          We define a third chip, the fit chip, which represents the goodness of
          fit at each equivalent position in the search chip.  That is, we can
          think of the pattern chip walking through the search chip and at each
          position extract a sub-region to be used for computing a fit
          value. After walking and computing at each position we have a chip
          filled with goodness of fit values that are in 1-1 correspondence with
          pixels in the search chip.  An example of the pattern chip weaving its
          way through the search chip is given:
        </p>
        <img src="assets/exampleWalk.jpg" alt="Example Walk" />
        <p>
          How the pattern chip walks the search chip can vary; currently we
          define one method: a dense walk.
        </p>

        <h3><a name="DenseWalk">Dense Walk</a></h3>
        <p>
          In the obvious case, we walk every possible position in the search
          chip by starting in the upper-left corner and moving over by one
          sample.  When we come to the right edge we will move down one line and
          reset to the left edge.  However, we do not test where the pattern
          would lie outside the search chip.  For example:
        </p>
        <img src="assets/denseWalk.jpg" alt="Dense Walk" />
        <p>
          In other words, we only test the pattern if it is fully inside of the
          search chip.  This will be true for all walking scenarios.  Therefore,
          if we have 3x3 pattern chip and a 7x7 search chip, we compute fits for
          25 of the 49 pixels in the search chip.
        </p>

        <!-- Sub-Pixel Accuracy -->
        <h2><a name="SubPixelAccuracy">Sub-Pixel Accuracy</a></h2>
        <p>
          Upon walking the pattern chip through the search chip we will have
          created the fit chip.  The highest (or lowest) goodness of fit value
          generally represents the whole pixel position that best matched between the
          pattern and search area.
        </p>
        <p>
          The Subpixel Algorithm option is on by default (SubpixelAccuracy=True),
          it is possible to turn it off by using the SubpixelAccuracy keyword.
          Example:
          <pre style="padding-left:4em;">
            Group = Algorithm
              Name             = MaximumCorrelation
              Tolerance        = 0.7
              SubpixelAccuracy = False
            End_Group
          </pre>

          In this case, the whole pixel with the best fit is returned.
        </p>

        <p>
           As of ISIS3.4.0, the subpixel algorithm was replaced with the algorithm
           described under SurfaceModeling. To estimate the true registration postion,
           the previous algorithm used a least squares fit to generate a 2nd degree
           2-dimentional polynomial given an NxN window of points from the fit chip.
           This previous algorithm optionally applied two parameter tolerances that
           are no longer needed and have been removed, Eccentricity Ratio and Residual Tolerance.
           If a PVL definition file includes these parameters when applying the new subpixel
           algorithm, they will simply be ignored.
        </p>

        <h3><a name="SurfaceModeling">Surface Modeling</a></h3>
        <p>
           When enabled, the subpixel accuracy algorithm analyzes a window size
           (WindowSize x WindowSize) block containing fit chip pixel values centered
           at the whole pixel with the best registration (local extreme value of the fit chip;
           the highest or the lowest value).
        </p>
        <p>
           The fit chip analysis is performed by using an adaptive flood fill and weighted average
           algorithm as follows:  (The figure below is based on a 5x5 WindowSize block of
           a fit chip returned by the Maximum Correlation algorithm).  The best registration
           among the border pixels of the WindowSize block (light orange colored pixel cells)
           is found (0.76 in the example below).  A continuous flood fill is done selecting all
           continuous pixels with registration values on the interval (0.76,1.0)-(the green
           colored cells).  An average of the selected cell coordinates is then computed
           (weighting each coordinate by it's registration value) to reduce the selection
           to a single location.
         </p>
         <p>
          <img src="assets/fitchip_windowsize.png" alt="WindowSize Block of a FIT Chip"/>
         </p>
         <p>
           It is required that 95% of the pixels within the fit chip block be valid.  Thus,
           in a 5x5 block, only one pixel could be invalid.  This is enforced primarily to
           avoid false positive registrations on image edges.
         </p>
         <p>
           The dimensions of the WindowSize fit chip block must be an odd number in order
           to have a center pixel. Also, the dimensions of the WindowSize fit chip block cannot
           be less than 5, but can be as large as the original fit chip
           (though this is not recommended). Recommended dimensions for
           (MaximumCorrelation and MinimumDifference) range from 5, 7, 9, 11, to 15.
         </p>
         <p>
           Optionally, the window size and tolerance may be supplied through PVL:

           <pre style="padding-left:4em;">
             Group = SurfaceModel
               DistanceTolerance = 0.75
               WindowSize        = 5
             End_Group
           </pre>
         </p>
        <h3><a name="DistanceTolerance">Distance Tolerance</a></h3>
        <p>
          The result of a sub-pixel accuracy computation is likely to move the
          result away from its original whole-pixel fit.  However, sometimes
          the move could be so drastic that it calls into question the validity
          of the match.  This tolerance value thus specifies the max number of
          pixels (with sub-pixel granularity) the sub-pixel accuracy
          computation can move the best fit before the registration is rejected
          entirely. The distance tolerance in pixels must be greater than 0 and is
          defaulted to 1.0.
        </p>
        <p>
          For example:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              DistanceTolerance = 3.5
            End_Group
          </pre>

          Here a registration will be rejected if the new position is more than
          3.5 pixels away from the original whole-pixel result.
          The recommended value is 0.5 or 0.75, this assumes that the orignal
          starting position at the whole pixel level is accurate.
          This distance test is not a 2D check, but rather, two single dimension
          checks (line direction and sample direction).
        </p>

        <h3><a name="WindowSize">Window Size</a></h3>
        <p>
          When refining a whole-pixel match to sub-pixel accuracy, it's
          important to consider how much area around that best whole-pixel fit
          to sample for subpixel analysis.  The WindowSize keyword
          defines the size of the window, centered on the best whole-pixel
          match, that will be used for subpixel refinement.  Values for
          WindowSize specify the N of an NxN chip, and must be odd numbers
          greater than or equal to 5.  By default, this window size is 5x5
          pixels, but can be specified in the SurfaceModel group as follows:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              WindowSize = 5
            End_Group
          </pre>

          Here we define our window to be 5x5 pixels around the best
          whole-pixel match, and the resulting surface will be modeled with
          the data in this chip.
        </p>

         <p>
           It is required that 95% of the pixels within the fit chip block be valid.  Thus,
           in a 5x5 block, only one pixel could be invalid.  This is enforced primarily to
           avoid false positive registrations on image edges.   An invalid pixel is defined
           as any 'Special Pixel' (NULL,HRS,LRS,etc) or if it is a value that falls
           outside the user specified 'ValidMinimum/ValidMaximum' parameter values.
         </p>
         <p>
           The dimensions of the WindowSize fit chip block must be an odd number in order
           to have a center pixel. Also, the dimensions of the WindowSize fit chip block cannot
           be less than 5, but can be as large as the original fit chip (though this is not recommended).
           Recommended dimensions for (MaximumCorrelation and MinimumDifference) range
           from 5, 7, 9, 11, to 15.
         </p>
        <p>
          If an ideal goodness of fit is found (e.g. 0.0 for MinimumDifference or 1.0 for
          MaximumCorrelation), we have a perfect fit and, thus, know it is in the best position.
          In this case, the sub-pixel accuracy phase is omitted.
        </p>

        <!-- Advanced Features -->
        <h2><a name="AdvancedFeatures">Advanced Features</a></h2>
        <p>
          This section covers advanced features of automatic
          registration.  While these features are not necessary in order to
          accomplish the registration, they can be used to significantly improve
          the chance of success and/or the accuracy of the match.
        </p>

        <h3><a name="RestrictingPixelRanges">Restricting Pixel Ranges</a></h3>
        <p>
          Pixels may be excluded from the match algorithm if they fall outside
          of a specified range.  This range is independent for both the pattern
          and search chip.  It is handled via the PVL as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples      = 5
                Lines        = 5
                ValidMinimum = 0.1
                ValidMaximum = 0.4
              End_Group

              Group = SearchChip
                Samples      = 21
                Lines        = 21
                ValidMinimum = 2.5
                ValidMaximum = 10.5
              End_Group

              ...
            End_Object
          </pre>

          If values are not given in the PVL then all pixels are considered
          valid (with the exception of special pixels).
        </p>

        <h3><a name="ValidPixelCount">Valid Pixel Count</a></h3>
        <p>
          Prior to the match algorithm being invoked during the walk process, a
          simple test is performed to ensure there are enough pixels to work
          with.  Pixels are deemed valid if they are in the minimum/maximum
          range and/or they are not special pixels.  The pattern chip is only
          checked once.  If it does not contain enough valid pixels the match is
          deemed to fail.  As the walk through occurs, the sub-region is
          extracted from the search chip. If this sub-region does not have
          enough valid pixels a match will be deemed to fail at that search
          location.  In the following PVL example we have a 5x5 chip with 25
          pixels of which 80% or more must be valid:

          <pre style="padding-left:4em;">
            Group = PatternChip
              Samples      = 5
              Lines        = 5
              ValidMinimum = 0.1
              ValidMaximum = 0.4
              ValidPercent = 80
            End_Group
          </pre>

          We only need to specify the percent for the pattern chip as the
          sub-region chip of the search area will use the same value.
        </p>

        <h3><a name="ReductionFactor">Reduction Factor</a></h3>
        <p>
          The automatic registration process can often be a time-consuming one,
          especially when needing to consider a large search area to walk
          through.  In order to help speed up this portion of the process, we
          introduce the notion of a "Reduction Factor".
        </p>
        <p>
          If a reduction factor greater than 1 is specified by the user, then
          before attempting to walk the pattern chip through the search chip
          looking for a match, the algorithm will first perform a "reduced
          match".  In other words, new pattern and search chips will be
          derived from the original chips with dimensions equal to the original
          chip dimensions divided by the ReductionFactor, in a manner similar to
          the reduce program, and a match will be performed on them first to help
          refine the general match to a smaller search area.  For example, a
          common reduction factor is 2, and can be specified in the definition file
          as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = Algorithm
                ReductionFactor = 2
              End_Group

              Group = PatternChip
                Samples      = 7
                Lines        = 7
              End_Group

              Group = SearchChip
                Samples      = 21
                Lines        = 21
              End_Group
            End_Object
          </pre>

          In the above example, a new pattern chip would be constructed with
          dimensions of 3 samples by 3 lines (i.e., 7 / 2 rounded down).  The
          new search chip, likewise, would be 10 samples by 10 lines (i.e., 21
          / 2).
        </p>
        <p>
          Of course, by reducing the chips we lose an amount of detail directly
          proportionate to the magnitude of the reduction factor.  Increasing
          the reduction factor will speed up computation, but also decrease the
          reliability of the result.  A pixel in a reduced chip is simply
          computed by averaging surrounding pixels in the original chip.
        </p>
        <p>
          After the match has been performed on the reduced chips, instead of
          simply accepting the result, the algorithm will continue on to
          matching the original chips, but decrease the search area to a
          smaller area surrounding the "best" sample and line derived from the
          reduced match, effectively cropping the search chip (not scaling it,
          as in the reduced match) to some general area suspected to contain
          the exact match.  Increasing the reduction factor will increase the
          size of the resulting search area.
        </p>
        <p>
          After finding the reduced match, the new search window is defined by
          expanding outwards from the best pixel (remapped from the reduced
          chips to the original chips) by:

          <pre style="padding-left:4em;">
            ReductionFactor + WindowSize + 1
          </pre>

          ...in all four directions.  The WindowSize can be specified by the
          user in the definition file's SurfaceModel group.  To help understand
          why the reduction factor is used in this manner, consider the
          following example:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = Algorithm
                ReductionFactor = 10
              End_Group

              Group = PatternChip
                Samples         = 700
                Lines           = 700
              End_Group

              Group = SearchChip
                Samples         = 1000
                Lines           = 1000
              End_Group

              Group = SurfaceModel
                WindowSize      = 3
              End_Group
            End_Object
          </pre>

          Using a reduction factor of 10: the search chip becomes 100x100, the
          pattern 70x70, and only 900 different comparison are made.  However,
          the best pixel match is only accurate to about 10 pixels because of
          the reduction.  So we repeat the matching process in a window around
          the best pixel.  The windows size is 10 in either direction plus the
          number of pixels needed for sub-pixel accuracy computations
          (WindowSize is usually 3).  In the our case the matching would be
          done on a 2 * (10 + 3 + 1) or 28x28 window, or 784 additional
          comparisons.  Therefore the total comparisons to get a match is 900 +
          784 = 1684 and is significantly less than the 90000 comparisons done
          without the reduction factor.
        </p>
        <p>
          Adaptive algorithms will make additional use the "best" sample and
          line derived from the reduced match when setting up affine
          transformations.
        </p>

        <h3><a name="GeoWarping">Geometric Warping of Pattern Cubes</a></h3>
        <p>
          The pattern cube can be forced to match the geometry of the search
          cube by using map projections and/or camera models.  Additionally,
          rotations can be applied to the pattern cube.  The warping is
          application-dependent and therefore is under the control of the
          programmer.  That is, there is no PVL mechanism for warp
          selection/deselection.
        </p>
        <p>
          However, when interpolating during the warp process, the user can
          choose, via the definition file, which interpolation algorithm to
          use.  Available interpolation algorithms include
          <a href="http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation">
            Nearest Neighbor
          </a>,
          <a href="http://en.wikipedia.org/wiki/Bilinear_interpolation">
            Bilinear
          </a>,
          and
          <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">
            Cube Convolution
          </a>.
          As an example of how to specify which algorithm to use:

          <pre style="padding-left:4em;">
            Group = Algorithm
              ChipInterpolator = NearestNeighborType
            End_Group
          </pre>

          The above example would warp the geometry of the pattern cube using
          the Nearest Neighbor algorithm.  For a complete list of all
          possible values for this keyword, see the
          <a href="#DeffileKeywords">Definition File Keywords</a>
          appendix below.
        </p>

        <h3><a name="ZScoreTest">Z-Score Test</a></h3>
        <p>
          To guarantee an accurate match, we first need to check if the pattern
          chip has enough variation to perform the algorithm on. This is done by
          calculating the z-score of both the minimum and maximum values of the
          chip. The z-score measures the number of standard deviations the value
          is away from the mean. If the z-score for either value is greater than
          the specified minimum value, then it is an acceptable pattern
          chip. For example:

          <pre style="padding-left:4em;">
            Group = PatternChip
              MinimumZScore = 1.5
            End_Group
          </pre>

          In this case, the chip's extreme values must be more than 1.5 standard
          deviations away from the mean. If the MinimumZScore keyword is not
          included, the default value of 1 standard deviation is used.
        </p>

        <h3><a name="GradientFilters">Gradient Filters</a></h3>
        <p>
          To increase the chances of successful registration, a gradient filter
          can be applied to both the search and pattern chips before attempting
          to perform a match.  In simple terms, a gradient filter highlights the
          edges in an image. Thus, the use of a gradient filter on the search and
          pattern chips may increase the chances of finding a match when the pattern
          chip contains distinctive features whose edges need to be emphasized.
          This is especially the case for search and pattern chips where the images
          have differing illumination conditions.
        </p>
        <p>
          Currently, the
          <a href="http://en.wikipedia.org/wiki/Sobel_operator">
            Sobel
          </a>
          gradient filter is supported. The Sobel gradient filter looks at
          the eight surrounding pixels for a given point. A Sobel gradient
          filter can be specified like so:

          <pre style="padding-left:4em;">
            Group = Algorithm
              Gradient = Sobel
            End_Group
          </pre>
        </p>

        <!-- Appendices -->
        <h2><a name="Appendices">Appendices</a></h2>
        <p>
          Here you'll find a collection of quick references to help improve
          your results when performing automatic registration.
        </p>

        <h3><a name="DeffileKeywords">Definition File Keywords</a></h3>
        <p>
          The following table provides an exhaustive listing of every
          <strong>keyword</strong> that can be provided in an automatic
          registration definition file.  The keywords are organized by what
          <strong>groups</strong> they can appear in after what
          <strong>algorithms</strong> they can be used with.  If a keyword can
          be used with every algorithm, then its value for this cell is "All".
          The <strong>type</strong> column specifies what kind of value is
          expected (an integer, real number, boolean, or a string).  The
          <strong>values</strong> column provides either the set of valid
          values (in the case of strings) or a numerical range, with a paren
          "(" denoting an exclusive value and a bracket "[" denoting an
          inclusive value.  The <strong>default</strong> column provides the
          value that will be taken when the keyword is not provided.  If the
          value for a particular cell is <span style="color:red;">red</span>,
          then instead of the corresponding keyword defaulting to some value in
          the registration process, the stated action will be performed.  In
          the case of an <span style="color:red;">Exception</span>, unless the
          specific application being used handles the missing value, the
          registration will fail.
        </p>

        <table class="tableFormattedInformation" align="center">
          <!-- Headers -->
          <tr>
            <th>Keyword</th>
            <th>Groups</th>
            <th>Algorithms</th>
            <th>Type</th>
            <th>Values</th>
            <th>Default</th>
          </tr>

          <!-- Algorithm -->
          <tr>
            <td><a href="#MatchAlgorithms"><strong>Name</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>String</td>
            <td>{MaximumCorrelation, MinimumDifference, Gruen, AdaptiveGruen}</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#Tolerance"><strong>Tolerance</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>Real</td>
            <td>[0.0, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#GeoWarping"><strong>ChipInterpolator</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>String</td>
            <td>{NearestNeighborType, BiLinearType, CubicConvolutionType}</td>
            <td>CubicConvolutionType</td>
          </tr>
          <tr>
            <td><a href="#ReductionFactor"><strong>ReductionFactor</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td>1</td>
          </tr>
          <tr>
            <td><a href="#SubPixelAccuracy"><strong>SubPixelAccuracy</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>Boolean</td>
            <td>{True, False}</td>
            <td>True</td>
          </tr>
          <tr>
            <td><a href="#GradientFilters"><strong>Gradient</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>String</td>
            <td>{None, Sobel}</td>
            <td>None</td>
          </tr>

          <!-- Pattern Chip -->
          <tr>
            <td><a href="#Chips"><strong>Samples</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#Chips"><strong>Lines</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#RestrictingPixelRanges"><strong>ValidMinimum</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>Isis::ValidMinimum</td>
          </tr>
          <tr>
            <td><a href="#RestrictingPixelRanges"><strong>ValidMaximum</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>Isis::ValidMaximum</td>
          </tr>
          <tr>
            <td><a href="#ZScoreTest"><strong>MinimumZScore</strong></a></td>
            <td>PatternChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, infinity)</td>
            <td>1.0</td>
          </tr>
          <tr>
            <td><a href="#ValidPixelCount"><strong>ValidPercent</strong></a></td>
            <td>PatternChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, 100.0]</td>
            <td>50.0</td>
          </tr>

          <!-- Search Chip -->
          <tr>
            <td><a href="#ValidPixelCount"><strong>SubchipValidPercent</strong></a></td>
            <td>SearchChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, 100.0]</td>
            <td>50.0</td>
          </tr>

          <!-- Surface Model -->
          <tr>
            <td><a href="#DistanceTolerance"><strong>DistanceTolerance</strong></a></td>
            <td>SurfaceModel</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, infinity)</td>
            <td>1.5</td>
          </tr>
          <tr>
            <td><a href="#WindowSize"><strong>WindowSize</strong></a></td>
            <td>SurfaceModel</td>
            <td>All</td>
            <td>Integer</td>
            <td>[3, infinity) odd</td>
            <td>5</td>
          </tr>

          <!-- Gruen -->
          <tr>
            <td><a href="#Gruen"><strong>MaximumIterations</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Integer</td>
            <td>(-infinity, infinity)</td>
            <td>25</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineTranslationTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.1</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineScaleTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.5</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineShearTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>AffineScaleTolerance</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>SpiceTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>RadioShiftTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>RadioGainMinTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>-DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>RadioGainMaxTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>FitChipScale</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.1</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>DefaultRadioGain</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.0</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>DefaultRadioShift</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.0</td>
          </tr>
        </table>

      </body>

      <type>HTML</type>
      <source>
        <filename>PatternMatch.html</filename>
      </source>
    </file>
  </files>

  <category>
    <categoryItem>guide</categoryItem>
  </category>

  <audience>
    <target>advanced</target>
  </audience>

  <bibliography>
    <title>Pattern Matching</title>
    <brief>
      A discussion of pattern matching techniques used in ISIS, designed to help
      users construct automatic registration templates.
    </brief>
    <description>
      This article describes the pattern matching techniques used for automatic
      registration in ISIS.  The information is designed to give users an idea
      of how they can alter their automatic registration templates to improve
      their results from applications such as "pointreg" and "coreg".  This
      should also give programmers a better understanding of how AutoReg works.
    </description>
    <author>Travis Addair</author>
    <date>2011-02-23</date>
  </bibliography>

  <history>
    <change name="Jeff Anderson and Travis Addair" date="2011-02-23">
      Original version
    </change>
    <change name="Jai Rideout" date="2011-03-10">
      Added gradient filter section
    </change>
    <change name="Moses Millazo and Jeff Anderson" date="2011-10-05">
      Updates to Gruen documentation, the eccentricity ratio, and the gradient
      filters.
    </change>
    <change name="Jai Rideout" date="2011-10-14">
      Removed references to Roberts gradient because it has been removed from
      AutoReg.
    </change>
    <change name="Tammy Becker" date="2012-08-15">
      Modified the description of the subpixel algorithm to Orrin Thomas's
      centroid/adaptive method.  Removed references to Eccentricity Ratio
      and Residual Tolerance. Added the 'fitchip' WindowSize box figure.
      A few minor additional corrections or modications throughout. Fixes #969.
    </change>
  </history>
</documentation>
